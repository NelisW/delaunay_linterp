{"name":"Delaunay linterp","tagline":"n-dimensional piecewise linear interpolation using Delaunay triangulation in C++","body":"Project page: http://rncarpio.github.com/delaunay_linterp\r\n\r\n### What is `delaunay_linterp`?\r\n`delaunay_linterp` is a C++ header-only library for N-dimensional piecewise linear interpolation of unstructured data, similar to Matlab's \r\n[griddata](http://www.mathworks.com/help/matlab/ref/griddata.html) and SciPy's [griddata](http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.griddata.html) commands. Suppose we are given a set of data\r\npoints `(x, f(x))` where `x` is N-dimensional. The idea is to construct an N-dimensional [Delaunay triangulation](http://en.wikipedia.org/wiki/Delaunay_triangulation) of the `x` coordinates of the data points; each vertex in the triangulation corresponds to a data point `(x, f(x))`. To compute an interpolated value for `xi`, we:\r\n* locate the simplex containing `xi`\r\n* calculate the barycentric coordinates of `xi` in the simplex\r\n* calculate `interp(xi)` as a weighted sum of the values of `f(x)` at the vertices of the simplex\r\nThe interpolated surface is linear within each simplex of the triangulation.\r\n\r\nThe [CGAL](http://www.cgal.org) computational geometry library is used for the underlying triangulation code. Other libraries that are used are:\r\n* [Boost](http://www.boost.org) - C++ libraries\r\n* [GMP](http://gmplib.org) - arbitrary precision arithmetic (on Windows, [MPIR](http://www.mpir.org/) is used)\r\n* [MPFR](http:/www.mpfr.org) - multi-precision floating point\r\n* [Eigen](http://eigen.tuxfamily.org) - C++ linear algebra\r\n\r\nPoints can be added incrementally. In addition, a function specifying `f(x)` can be passed to the triangulation.  `delaunay_linterp` can adaptively choose where to insert data points, by maintaining a list of approximation errors associated with each simplex of the triangulation. This allows a good approximation of arbitrary functions with few data points, compared to regular grids.\r\n\r\n### C++ interface\r\nHere is an example in C++:\r\n```c++\r\n#include <ctime>\r\n#include \"delaunay_2_interp.h\"\r\n\r\n// return an evenly spaced 1-d grid of doubles.\r\nstd::vector<double> linspace(double first, double last, int len) {\r\n  std::vector<double> result(len);\r\n  double step = (last-first) / (len - 1);\r\n  for (int i=0; i<len; i++) { result[i] = first + i*step; }\r\n  return result;\r\n}\r\n\r\n// the function to interpolate.\r\ndouble fn (double x1, double x2) { return pow(x1,0.3) * pow(x2,0.6); }\r\n\r\nint main(int argc, char **argv) {\r\n  int n_points = 10;\r\n  clock_t t1, t2;      \r\n\r\n  // first, try a rectangular grid\r\n  Delaunay_incremental_interp_2 triang;\r\n  std::vector<double> grid = linspace(0., 5., n_points);\r\n  t1 = clock();\t\r\n  for (int i=0; i<n_points; i++) {\r\n    for (int j=0; j<n_points; j++) {\r\n\t  array<double,2> args = {grid[i], grid[j]};\r\n      triang.insert(args.begin(), args.end(), fn(args[0], args[1]));\r\n    }\r\n  }\r\n  t2 = clock();\r\n  printf(\"regular grid: %d insertions, %d clocks, %f sec\\n\", n_points*n_points, (t2-t1), ((double)(t2 - t1)) / CLOCKS_PER_SEC);\r\n\r\n  // second, try adaptive point placement\r\n  std::function<double(double, double)> fn_obj(fn);\r\n  Delaunay_incremental_interp_2 adaptive_triang(fn_obj);\r\n  // insert boundary points\r\n  array<double,2> args;\r\n  t1 = clock();\r\n  args[0]=grid.front(); args[1]=grid.front();\tadaptive_triang.insert(args.begin(), args.end(), fn(args[0], args[1]));\r\n  args[0]=grid.front(); args[1]=grid.back();\tadaptive_triang.insert(args.begin(), args.end(), fn(args[0], args[1]));\r\n  args[0]=grid.back(); args[1]=grid.front();\tadaptive_triang.insert(args.begin(), args.end(), fn(args[0], args[1]));\r\n  args[0]=grid.back(); args[1]=grid.back();\t\tadaptive_triang.insert(args.begin(), args.end(), fn(args[0], args[1]));\r\n  for (int i=0; i<n_points*n_points-4; i++) {\r\n    adaptive_triang.insert_largest_error_point();\r\n  }\t\r\n  t2 = clock();\r\n  printf(\"adaptive grid: %d insertions, %d clocks, %f sec\\n\", n_points*n_points, (t2-t1), ((double)(t2 - t1)) / CLOCKS_PER_SEC);\r\n\r\n  // compare interpolated value vs. actual function\r\n  std::vector<double> true_f_vals, interp_grid = linspace(0., 5., 2*n_points);  \r\n  for (int i=0; i<interp_grid.size(); i++) {\r\n    for (int j=0; j<interp_grid.size(); j++) {\r\n\t  array<double,2> args = {interp_grid[i], interp_grid[j]};\r\n\t  true_f_vals.push_back(fn(args[0], args[1]));\r\n\t}\r\n  }\r\n\r\n  // get the interpolated values  \r\n  std::vector<double> regular_triang_vals, adaptive_triang_vals;\r\n  t1 = clock();\t  \r\n  for (int i=0; i<interp_grid.size(); i++) {\r\n    for (int j=0; j<interp_grid.size(); j++) {\r\n\t  array<double,2> args = {interp_grid[i], interp_grid[j]};\r\n\t  regular_triang_vals.push_back(triang.interp(args.begin(), args.end()));\r\n\t}\r\n  }\r\n  t2 = clock();\r\n  printf(\"regular grid: %d interpolations, %d clocks, %f sec\\n\", regular_triang_vals.size(), (t2-t1), ((double)(t2 - t1)) / CLOCKS_PER_SEC);\r\n  t1 = clock();\t  \r\n  for (int i=0; i<interp_grid.size(); i++) {\r\n    for (int j=0; j<interp_grid.size(); j++) {\r\n\t  array<double,2> args = {interp_grid[i], interp_grid[j]};\r\n\t  adaptive_triang_vals.push_back(adaptive_triang.interp(args.begin(), args.end()));\r\n\t}\r\n  }\r\n  t2 = clock();\r\n  printf(\"adaptive grid: %d interpolations, %d clocks, %f sec\\n\", adaptive_triang_vals.size(), (t2-t1), ((double)(t2 - t1)) / CLOCKS_PER_SEC);\r\n  \r\n  // compute sum of squared errors\r\n  double sse1=0.0, sse2=0.0, diff;\r\n  for (int i=0; i<true_f_vals.size(); i++) {\r\n    diff = true_f_vals[i] - regular_triang_vals[i];\r\n    sse1 += diff*diff;\r\n\tdiff = true_f_vals[i] - adaptive_triang_vals[i];\r\n\tsse2 += diff*diff;\r\n  }\r\n  printf(\"regular grid: sum of squared errors: %f\\n\", sse1);\r\n  printf(\"adaptive grid: sum of squared errors: %f\\n\", sse2);\r\n  \r\n  return 0;\r\n}\r\n```\r\nproduces:\r\n```\r\nregular grid: 100 insertions, 6 clocks, 0.006000 sec\r\nadaptive grid: 100 insertions, 11 clocks, 0.011000 sec\r\nregular grid: 400 interpolations, 2 clocks, 0.002000 sec\r\nadaptive grid: 400 interpolations, 2 clocks, 0.002000 sec\r\nregular grid: sum of squared errors: 5.800002\r\nadaptive grid: sum of squared errors: 0.044019\r\n```\r\n\t\r\n### License: GPLv3\r\n\r\ndelaunay_linterp is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.","google":"UA-27074418-2","note":"Don't delete this file! It's used internally to help with page regeneration."}